<!DOCTYPE html>




<html class="theme-next mist" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  

  

  

  

  

  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/cw-215x215-20180526.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/cw-32x32-20180526.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/cw-16x16-20180526.png?v=5.1.4">






  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Life is fantanstic!">
<meta property="og:type" content="website">
<meta property="og:title" content="Caveman.Work Blog">
<meta property="og:url" content="http://caveman.work/index.html">
<meta property="og:site_name" content="Caveman.Work Blog">
<meta property="og:description" content="Life is fantanstic!">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Caveman.Work Blog">
<meta name="twitter:description" content="Life is fantanstic!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://caveman.work/"/>





  <title>Caveman.Work Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?8a854e3b5b79b6cde354ce85895c1ffb";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script><!-- hexo-inject:begin --><!-- hexo-inject:end -->




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="site-title">Caveman.Work Blog</span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Blog
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            Contact
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2019/07/12/Software-Performance-Engineering/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/12/Software-Performance-Engineering/" itemprop="url">Software Performance Engineering</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-07-12T23:18:27+08:00">
                2019-07-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="软件性能工程-「Software-Performance-Engineering」"><a href="#软件性能工程-「Software-Performance-Engineering」" class="headerlink" title="软件性能工程 「Software Performance Engineering」"></a>软件性能工程 「Software Performance Engineering」</h1><p>本文使用不到五分钟的阅读时间来阐述软件性能工程里的关键知识点，有助于大家在规划软件项目时，通过引入性能工程以提高软件项目的可用性与市场成功率。简单来说，软件性能工程是通过将性能指标维度纳入到软件开发周期中的各关键节点，通过事前规划与各里程碑节点上的关键验收，来追求最终交付的软件质量是符合设计预期的。</p>
<h1 id="它的价值在哪里？"><a href="#它的价值在哪里？" class="headerlink" title="它的价值在哪里？"></a>它的价值在哪里？</h1><p>在开发软件时（不包含简单的脚本类程序），有时候会优先考虑把功能做完，即所谓的Make it run first。此时大部分的精力都放在了功能开发上，对性能指标的考虑是放在第二，甚至第三位的。有时候甚至不考虑性能，只有当客户反馈了问题之后才会着手去优化代码。 </p>
<p>这种做事方法就不是一个工程师思维的做事方式，更像是产品经理的思维。先把东西弄出来，试一试，看看效果怎么样。这种是在小规模，或者影响可控的范围内是可行的，但这并不是常态。更常见的情况是，工程师根据比较明确的需求通过项目管理（如敏捷开发）的方式进行工程开发，为了使交付效率与质量最高，必须遵照一定的工程化方式做事情。性能工程能帮助项目解决的难题如下：</p>
<ul>
<li>可避免性能瓶颈是因软件架构引起的问题，这是典型的低概率但后果严重的错误。一旦遇到这类问题，通过优化几处热点代码是无法根治的，需要彻底的重构。</li>
<li>用户反馈的问题无法通过有效的手段、日志来定位问题，只能通过成本最高的方式，也就是让用户复现问题的方式来定位问题。</li>
<li>硬件容量规划时无法根据之前的项目经验进行量化分析。</li>
</ul>
<h1 id="SPE-Lite版执行流程"><a href="#SPE-Lite版执行流程" class="headerlink" title="SPE Lite版执行流程"></a>SPE Lite版执行流程</h1><p>具体怎么执行呢？性能工程是一个完整的工程学科，这篇短文当然无法完整的描述所有的细节，所有的知识点。就着够用就好的原则，仅介绍最关键的执行步骤，读者可感受下画风。</p>
<ol>
<li>通过用户调研与竞品分析，定义关键用户性能指标，如：吞吐量，传输速度，界面刷新帧率</li>
<li>设计可满足业务需求与性能指标的软件架构</li>
<li>对性能指标建模<ul>
<li>如果是排队系统时，使用排队论建模工具</li>
</ul>
</li>
<li>开发性能指标测试工具与测试用例</li>
<li>开发用于记录性能指标变化的监控器<ul>
<li>制定性能数据本地存储规则</li>
<li>制定性能数据云端回传规则</li>
</ul>
</li>
<li>制作性能数据可视化表盘</li>
</ol>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><ul>
<li>做事讲究方法，套路。这些方法，用现在的话来说就是各种思维模式。</li>
<li>从之前火热的互联网思维，到近几年流行的产品思维，本质上都是做事方式，其目的也非常简单，那就是更好地做事。</li>
<li>通过更好地做事，才有可能做出优秀的产品，只有优秀产品才有可能提高市场竞争力。当产品有了市场竞争力，才有可能赢得其他方面的成功，比如商业。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2019/06/01/Data-science-for-mobile-OS-system-optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/01/Data-science-for-mobile-OS-system-optimization/" itemprop="url">Data science for mobile OS system optimization</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-06-01T21:23:17+08:00">
                2019-06-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update 201906016</em></p>
<h2 id="做些铺垫"><a href="#做些铺垫" class="headerlink" title="做些铺垫"></a>做些铺垫</h2><p>当今嵌入式设备OS系统优化面临的挑战难题有：</p>
<ol>
<li>造成发热，卡顿，待机时间差的主要瓶颈是什么？</li>
<li>当设置内核，JVM，资源管理功能的参数时，到底该怎么设置才合理？</li>
<li>如何全面的评估某个算法的优化效果？</li>
</ol>
<p>想要回答上面几个问题，目前的做法是根据几个有效日至或者通过本地复现的手段来寻找线索。虽然可以回答问题，也有理有据，但他的准确度是值得怀疑的。<strong> 最根本的原因是样本量太少！</strong><br>以问题3为例，假设是在评估某个CPU Affinity分配算法。可以通过单个或多个的benchmark结果来评估算法效果，但还是有可能发生“不知道的不知道”。</p>
<p>为了避免发生“不知道的不知道”，我们可以采用如下方法：</p>
<ol>
<li>构建实验组与对照组，通过对比实验的方式量化优化效果。评估单维度指标，也可以同时评估多个维度的指标变化。</li>
<li>量化不同算法下的系统主要瓶颈变化，用于排除优化一个场景反而带来另一个场景的性能降低。</li>
</ol>
<p>为了实现方法1,2，我们应该具备如下能力：</p>
<ul>
<li>低负载的多维度数据监控与存储器。</li>
<li>大数据分析能力。</li>
<li>全栈业务领域知识。</li>
</ul>
<h2 id="数据科学"><a href="#数据科学" class="headerlink" title="数据科学"></a>数据科学</h2><p>那我们怎么才能系统化的建设这方面能力呢？下面引申出本文章的主题，数据科学。</p>
<blockquote>
<p>Data science is a multi-disciplinary field that uses scientific methods, processes, algorithms and systems to extract knowledge and insights from structured and unstructured data. - 维基百科</p>
</blockquote>
<p>这里的关键词是 scientific method，extract knowledge and insights。使用科学的方法，从数据中获得洞见。随着大数据技术的完善与普及，通过利用大量采集而来的数据来认识事物本质成为了可能。而我们习惯的思考模式是从个别现象中寻找共性，然后再用大量事实来验证此共性是否准确。 第二种方法进展缓慢，且成本也大。但第一种就不一样了，随着数据的存储跟计算越来越便宜，我们可以直接使用数据获得有用的洞见。</p>
<p>若想成功应用数据科学，需要兼备如下多学科知识跟技能：</p>
<ul>
<li>概率与统计学</li>
<li>机器学习</li>
<li>业务领域知识</li>
<li>计算机科学</li>
<li>代码编程</li>
<li>数据可视化</li>
<li>表达与沟通</li>
</ul>
<h2 id="应用数据可学的步骤"><a href="#应用数据可学的步骤" class="headerlink" title="应用数据可学的步骤"></a>应用数据可学的步骤</h2><p>针对系统优化领域，我们应该怎么使用数据科学方法获得洞见呢？ 我认为以下6个步骤是必须的，而且严格按照顺序执行：</p>
<ol>
<li>定义分析目的</li>
<li>定义有效的评估指标</li>
<li>数据收集器的设计与实现</li>
<li>根据分析目的，选择对应的分析模型来分析数据</li>
<li>寻找洞见</li>
<li>根据洞见反推设计，并得到改善</li>
</ol>
<h3 id="步骤1-定义分析目的"><a href="#步骤1-定义分析目的" class="headerlink" title="[步骤1] 定义分析目的"></a>[步骤1] 定义分析目的</h3><p>分析目的不同设计的指标与分析方法也不同，常见的分析目的有：</p>
<ul>
<li>趋势观察</li>
<li>A/B Test</li>
<li>异常时问题分析</li>
<li>瓶颈分析</li>
<li>异常预警</li>
</ul>
<h3 id="步骤2-定义有效的评估指标"><a href="#步骤2-定义有效的评估指标" class="headerlink" title="[步骤2] 定义有效的评估指标"></a>[步骤2] 定义有效的评估指标</h3><p>这步骤主要考验领域知识的掌握深度，因为指标的主要来源以及服务目标就是来自于业务。指标定义要优先于优化方案评估，目的在于你的优化方案要为指标的优化而努力。这时候指标更像是一种优化目标的量化方法，如果优化目标无法量化也意味着你的不明白你到底要做什么。   好指标应当结合业务需求，技术需求的不同角度来综合设计。 比如谷歌的WSMeter指标，阿里数据中心的WorkDone指标。通过思考指标的定义，也促使自己思考优化的方向。一个好的指标，像个灯塔一样，非常准确地指引着优化目标，而一个坏的指标往往会导致顾此失彼的结果。</p>
<p>提到指标，就不得不提到北极星指标（North Start Metric），又被称为唯一重要的指标。它是用户增长领域里的概念，意指像北极星一样高高闪耀在天空中，指引着全公司上上下下向着同一个方向努力。虽然关注领域有点不同，但是所要达成的目标是一致的，即能够准确量化最关键的业务目标。读者可以感受下制定北极星指标时需要遵守的几个标准：</p>
<blockquote>
<p>标准1：你的产品的核心价值是什么？这个指标可以让你知道你的用户体验实现了这种价值吗？<br>标准2：这个指标能够反映用户的活跃程度吗？<br>标准3：如果这个指标变好了，是不是能说明你的整个公司是在向好的方向发展？<br>标准4：这个标准是不是很容易被你的整个团队理解和交流呢？<br>标准5：这个指标是一个先导指标，还是一个滞后指标？<br>标准6：这个指标是不是一个可操作的指标？</p>
</blockquote>
<h3 id="步骤3-数据收集器的设计与实现"><a href="#步骤3-数据收集器的设计与实现" class="headerlink" title="[步骤3] 数据收集器的设计与实现"></a>[步骤3] 数据收集器的设计与实现</h3><p>收集器需要参考指标的定义来设计，有些数据的采集难度或者成本较高，这时候可以通过巧妙的指标来弥补这部分缺点。有时候因为现有机制缺少相关的数据提供方式，需要单独实现一套高效率的收集机制，特别是牵涉到内核级别的数据时往往都会采用定制方法。<br>综合来说主要原则有两个：</p>
<ul>
<li>数据能够准确的代表业务，这是基础中的基础。</li>
<li>收集数据时工作负载要小，需要控制在一定影响范围内。如果无法保证性能的话需要采用发布策略在尽可能不打扰用户的前提下抓取数据。</li>
<li>数据能完整地涵盖业务变化，宁可多收集一些冗余数据但不能容忍有遗漏。</li>
</ul>
<h3 id="步骤4-根据分析目的，选择对应的分析模型来分析数据"><a href="#步骤4-根据分析目的，选择对应的分析模型来分析数据" class="headerlink" title="[步骤4] 根据分析目的，选择对应的分析模型来分析数据"></a>[步骤4] 根据分析目的，选择对应的分析模型来分析数据</h3><p>为了达成有效的数据实验，需要熟悉各种数据挖掘技术（算法），除了工作原理之外还有就是他们的最佳应用场景。根据分析目的为分类的话：</p>
<p>1：分析目的为趋势观察时：<br>只需要将收集上来的数据进行ETL之后使用可视化工具展示就可以了，这里的难点在于可视化图表的选择上，选择原则为：</p>
<ul>
<li>尽量使读者看图知意，不需要过多的猜测与思考以免造成误解。</li>
<li>可视化图表需要展示完整的数据。</li>
</ul>
<p>2：分析目的为异常分析时：<br>基本以非结构化数据为主，分析主要结合领域知识跟专家系统做分析平台。经常会被产品化团队当做主要分析目的使用。</p>
<p>3：分析目的为瓶颈分析与异常预警时：<br>基本以结构化日志为主，使用的算法主要来自机器学习领域。</p>
<p>常见的数据挖掘技术有：</p>
<blockquote>
<ul>
<li>决策树（Decision Tree）</li>
<li>神经网络（Neural Network）</li>
<li>回归（Regression）</li>
<li>关联规则（Association Rule）</li>
<li>聚类（Clustering）</li>
<li>贝叶斯分类方法（Bayesian Classifier）</li>
<li>支持向量机（Support Vector Machine）</li>
<li>主成分分析（Principal Components Analysis）</li>
<li>假设检验（Hypothesis Test）</li>
</ul>
</blockquote>
<h3 id="步骤5-寻找洞见"><a href="#步骤5-寻找洞见" class="headerlink" title="[步骤5] 寻找洞见"></a>[步骤5] 寻找洞见</h3><p>这一步重点在于使用业务知识来解读步骤4中生成的数据结论。从经验上来看，往往决定胜负的并不是数据挖掘技术，而是来自于对业务的深刻理解上。这时候数据结果起到辅助判断的作用，所以万不可盲目崇拜数据技术而不重视业务知识。特别需要注意的是当业务专家与算法计算结果发生冲突的时候，这可能是一个潜在的优化点。</p>
<h3 id="步骤6-根据洞见反推设计，并得到改善"><a href="#步骤6-根据洞见反推设计，并得到改善" class="headerlink" title="[步骤6] 根据洞见反推设计，并得到改善"></a>[步骤6] 根据洞见反推设计，并得到改善</h3><p>前面的努力都是为了这一刻，从步骤5中获得的洞见将会指导我们重新审视现有的方案，或者验证我们的猜想。这一步是我们的终极目的，只有反哺到了现有业务，才是真正有效的一次数据应用实践。但这并不意味着结束，通过此步骤得到结果，我们可以发起下一轮的实验，即返回到了步骤1。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>人的认知提升是一个螺旋上升的过程，不要指望一把命中目标，我们应该具备的思维方式是迭代式改进的思维模式（或者说是演化思维）。在后果可控的前提下可以犯错，可以做实验，这一次实验是要站在前一次实验的基础上。通过这种方法不敢保证一定会成功，但它是成功概率最高的一种做事方法。</li>
<li>理论知识往往都很好学，很好理解，难点就在于时刻把理论应用到现实中，从现实中验证理论。有点像学习经济学思维一样，他并不要求你能背诵多少个经济学名词，反而更关心经济学规律如何在现实中得到应验，以及如何使用规律构建规则使社会运行效率最大化。</li>
<li>未来是属于数据间的竞争，而数据竞争的源头来自于指标的定义。一个好的指标定义很大程度上决定了，通过数据科学的方式优化业务的效果，务必要给予高度重视，需要时刻反思指标的正确性。</li>
<li>经济学原理指出，当交易成本近乎为零时，谁更能利用好资源，那资源就归谁。同样道理，数据本身只是存储在服务器里，谁能挖掘到洞察，谁就得到金子。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>张溪梦：首席增长官：如何用数据驱动增长</li>
<li>卢辉：数据挖掘与数据化运营实战：思路，方法，技巧与应用</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2019/01/29/eBPF-on-Android/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/29/eBPF-on-Android/" itemprop="url">eBPF on Android</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-29T16:29:33+08:00">
                2019-01-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update 20190601</em></p>
<h2 id="做些铺垫"><a href="#做些铺垫" class="headerlink" title="做些铺垫"></a>做些铺垫</h2><p>本文假设读者已掌握如下内容：</p>
<ol>
<li>熟悉Linux内核编译方法。</li>
<li>阅读过博文<a href="http://www.caveman.work/2019/01/28/eBPF%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E7%95%85%E6%83%B3/" target="_blank" rel="noopener">eBPF架构优势及其应用方向上的畅想</a>。</li>
<li>熟悉Git操作</li>
<li>熟悉CMake，LLVM，Clang等编译工具</li>
</ol>
<p>在博文<a href="http://www.caveman.work/2019/01/28/eBPF%E6%9E%B6%E6%9E%84%E4%BC%98%E5%8A%BF%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8%E6%96%B9%E5%90%91%E4%B8%8A%E7%9A%84%E7%95%85%E6%83%B3/" target="_blank" rel="noopener">eBPF架构优势及其应用方向上的畅想</a>中有提到eBPF的执行流程，这套在主机系统（泛指基于x86的Linux distribution）上直接apt install或者源码编译安装就可以了。但是在android上怎么执行呢？ 现在大部分android设备运行在基于arm的处理器架构上，我们熟悉的高通，MTK，华为海思都属于arm处理器架构。x86上的eBPF工具栈（如前文所述，这里仅指BCC&amp;BPFTrace）程序是无法直接在arm处理器上执行的，需要所谓的交叉编译技术才可以。除了程序本身之外，它所依赖的基础库如libc也同样需要交叉编译才能正确工作。</p>
<h3 id="运行在android时的难题"><a href="#运行在android时的难题" class="headerlink" title="运行在android时的难题"></a>运行在android时的难题</h3><ol>
<li>BCC及BPFTrace使用的是基于CMake的编译方式，与android使用的gradle，android BP的编译系统是不一致的。</li>
<li>BCC项目中以python 包为基础，那意味着需要有python运行环境，这在anroid里也是没有的。</li>
</ol>
<h3 id="可行的思路"><a href="#可行的思路" class="headerlink" title="可行的思路"></a>可行的思路</h3><ol>
<li>没条件就创造条件，将BCC&amp;BPFTrace强行适配到android编译环境，使其可以直接运行在android上下文中。中间涉及的依赖，冲突问题需要手动修改。</li>
<li>添加中间层，由host端生成的的bytecode通过adb通道派发给client端，具体执行由client端的常驻进程完成。</li>
<li>android端运行某个linux distribution环境（如Debian，Ubuntu），在手机端编译与安装BCC&amp;BPFTrace。</li>
<li>参考BCC&amp;BPFTrace设计思路，依照android的架构实现一套类似功能程序，部分采用BCC&amp;BPFTrace项目代码。</li>
</ol>
<p>综合利弊之后，本文使用方案3。缺点就是对android的环境要求比较高，它需要：</p>
<ol>
<li>手机能够root，而且可以将data分区remount成可读写。</li>
<li>android kernel 版本要求在4.9及以上。 </li>
<li>具有编译android kernel的环境。</li>
</ol>
<h2 id="步骤1-编译带必要功能的内核"><a href="#步骤1-编译带必要功能的内核" class="headerlink" title="步骤1 编译带必要功能的内核"></a>步骤1 编译带必要功能的内核</h2><p>通过手动编内核实现以下两个目的：</p>
<ul>
<li>使能eBPF相关功能（如果已经开启可以跳过此步骤）。</li>
<li>获取特定kernel的头文件。BCC会用到此头文件中的结构体来解析eBPF的返回数据。</li>
</ul>
<p>1：开启以下内核配置到项目_defconfig文件中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_BPF=y</span><br><span class="line">CONFIG_BPF_JIT=y</span><br><span class="line">CONFIG_HAVE_BPF_JIT=y</span><br><span class="line">CONFIG_BPF_EVENTS=y</span><br><span class="line">CONFIG_KPROBES=y</span><br><span class="line">CONFIG_KPROBE_EVENT=y</span><br><span class="line">CONFIG_UPROBES=y</span><br><span class="line">CONFIG_UPROBE_EVENT=y</span><br><span class="line">CONFIG_DEBUG_PREEMPT=y</span><br><span class="line">CONFIG_PREEMPTIRQ_EVENTS=y</span><br><span class="line">CONFIG_FTRACE_SYSCALLS=y</span><br></pre></td></tr></table></figure></p>
<p>2：根据项目情况编译内核</p>
<ul>
<li>如果你有完整android项目代码的话可以make bootimage编译出内核</li>
<li>否则配置好交叉编译环境后单独编译内核。</li>
</ul>
<p>关于获取Linux  kernel 头文件：</p>
<ul>
<li>如果你直接使用交叉编译环境来编译内核的话可以忽略这段内容。</li>
<li>如果你的内核改动比较少，算是比较”干净”的话可以直接使用别人已经打包好的头文件包。不过这种情况比较少见，嵌入式的linux 内核基本被芯片厂或手机厂有所修改。</li>
<li>如果你是用android树来编译内核的话，需要手动编译头文件因为android的打包结构并不保留头文件。编译方法如下：<ol>
<li>cd to kernel tree </li>
<li>export ARCH=arm64</li>
<li>export CROSS_COMPILE=aarch64-linux-gnu- (任意交叉编译器都可以)</li>
<li>make boardname_defconfig</li>
<li>make -j6 </li>
</ol>
</li>
</ul>
<h2 id="步骤2-安装debian-arm到Android"><a href="#步骤2-安装debian-arm到Android" class="headerlink" title="步骤2 安装debian-arm到Android"></a>步骤2 安装debian-arm到Android</h2><p>Github有叫adeb项目，它的功能是将debian-arm整个固件push到android设备的/data目录下，然后并通过本地shell的配合实现了debian环境下shell。也就是debian能支持的功能他都能支持，只是没有屏幕，只能通过终端控制。当然也支持apt命令，通过修改源（apt source）之后下载安装社区提供的各种软件。</p>
<ol>
<li>首先下载adeb项目 git clone <a href="https://github.com/joelagnel/adeb.git" target="_blank" rel="noopener">https://github.com/joelagnel/adeb.git</a></li>
<li>然后执行安装命令，此时需要手机已经是root，并且确保剩余空间至少大于300MB。adeb的其他命令具体参考reference guide，参考引用2。</li>
<li>adeb prepare –full  –kernelsrc /path/to/kernel-source   // 步骤1中提及的kernel路径</li>
<li>adeb shell </li>
</ol>
<p>即可进入到基于debian运行环境的shell。 他相比android区别在于只是利用了android中运行的linux kernel而其他标准库之类（bionic，linker等）都替换成debian所提供的libc及linker。安装过程及运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$  adeb prepare --full --kernelsrc ./msm-4.9_valina_sdm845       </span><br><span class="line">|--------------|</span><br><span class="line">| adeb: v0.99g |</span><br><span class="line">|--------------|</span><br><span class="line">16:01:15 - INFO    : Looking for device..</span><br><span class="line">16:01:15 - INFO    : Preparing device...</span><br><span class="line">16:01:15 - INFO    : Doing a full install.</span><br><span class="line">16:01:15 - INFO    : </span><br><span class="line">16:01:15 - INFO    : Downloading Androdeb from the web...</span><br><span class="line">16:01:15 - INFO    : </span><br><span class="line">16:01:15 - INFO    : No repository URL provided in enviromnent. Attempting to auto-detect it</span><br><span class="line">16:01:15 - INFO    : Detected URL: github.com/joelagnel/adeb/</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   610    0   610    0     0    589      0 --:--:--  0:00:01 --:--:--   589</span><br><span class="line">100  295M  100  295M    0     0   400k      0  0:12:36  0:12:36 --:--:--  541k</span><br><span class="line">Archive:  /tmp/tmp.A2epoY9AOr/androdeb-fs.tgz.zip</span><br><span class="line">  inflating: /tmp/tmp.A2epoY9AOr/androdeb-fs.tgz  </span><br><span class="line">16:01:53 - INFO    : Building and updating kernel headers from kernel source dir (./msm-4.9_valina_sdm845)</span><br><span class="line">16:01:58 - INFO    : Using archive at /tmp/tmp.A2epoY9AOr/androdeb-fs.tgz for filesystem preparation</span><br><span class="line">16:01:58 - INFO    : Pushing filesystem to device..</span><br><span class="line">16:01:09 - INFO    : Pushing addons to device..</span><br><span class="line">16:01:10 - INFO    : Unpacking filesystem in device..</span><br><span class="line">16:01:30 - INFO    : Storing kernel headers into androdeb /kernel-headers/</span><br><span class="line">16:01:57 - INFO    : All done! Run &quot;adeb shell&quot; to enter environment</span><br><span class="line"></span><br><span class="line">$  adeb shell </span><br><span class="line"></span><br><span class="line">##########################################################</span><br><span class="line"># Welcome to androdeb environment running on Android!    #</span><br><span class="line"># Questions to: Joel Fernandes &lt;joel@joelfernandes.org&gt;  #</span><br><span class="line">                                                         #</span><br><span class="line"> Try running vim, gcc, clang, bcc, git, make, perf etc   #</span><br><span class="line">   or apt-get install something.                         #</span><br><span class="line">##########################################################</span><br><span class="line"></span><br><span class="line">root@localhost:/#</span><br></pre></td></tr></table></figure>
<p>AOSP项目源码仓库中的 <a href="https://android.googlesource.com/platform/external/adeb/" target="_blank" rel="noopener">external目录</a> 下面谷歌已经集成了adeb项目，如果有AOSP源码的话可以直接使用项目中的源码。这部分更新还未集成到Android P，应该是会随着Android Q一起发布。 </p>
<h2 id="Hello-world"><a href="#Hello-world" class="headerlink" title="Hello world"></a>Hello world</h2><p>例1<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/usr/share/bcc/tools# vfsstat </span><br><span class="line">TIME         READ/s  WRITE/s CREATE/s   OPEN/s  FSYNC/s</span><br><span class="line">08:45:23:        98      369        0        5        0</span><br><span class="line">08:45:24:       287      261        0      144        0</span><br><span class="line">08:45:25:       115      129        0       49        0</span><br><span class="line">08:45:26:       253      125        0       92        0</span><br><span class="line">08:45:27:       326      272        0       74        0</span><br><span class="line">08:45:28:       217      229        0       61        0</span><br></pre></td></tr></table></figure></p>
<p>vfsstat(Virtual FileSystem Stats)可以查看下发到虚拟文件系统层的所有IO请求，如果看到以上结果就说明大功告成啦！过程中如果出现问题的话可以参考引用3。我自己遇到过kernel head不匹配与没有开启eBPF导致的错误。<br>预编译好的bcc工具集目录在 /usr/share/bcc/tools， 目前将近有100多个小工具。</p>
<p>例2<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@localhost:/usr/share/bcc/tools# tcpdrop </span><br><span class="line">TIME     PID    IP SADDR:SPORT          &gt; DADDR:DPORT          STATE (FLAGS)</span><br><span class="line">08:54:36 3257   6  ::ffff:172.28.140.149:80 &gt; ::ffff:183.60.137.144:46922 ESTABLISHED (ACK)</span><br><span class="line">        tcp_drop+0x0</span><br><span class="line">        tcp_rcv_established+0x2d4</span><br><span class="line">        tcp_v4_do_rcv+0x198</span><br><span class="line">        tcp_v4_rcv+0xb54</span><br><span class="line">        ip_local_deliver_finish+0x10c</span><br><span class="line">        ip_local_deliver+0x108</span><br><span class="line">        ip_rcv_finish+0x168</span><br><span class="line">        ip_rcv+0x344</span><br><span class="line">        __netif_receive_skb_core+0x5a8</span><br><span class="line">        __netif_receive_skb+0x38</span><br><span class="line">        process_backlog+0xd0</span><br><span class="line">        net_rx_action+0x258</span><br><span class="line">        __softirqentry_text_start+0x15c</span><br><span class="line">        do_softirq+0x70</span><br><span class="line">        netif_rx_ni+0x80</span><br><span class="line">        hdd_rx_packet_cbk+0x438</span><br><span class="line">        $x+0x310</span><br><span class="line">        $x+0x1e8</span><br><span class="line">        kthread+0xf4</span><br><span class="line">        ret_from_fork+0x10</span><br></pre></td></tr></table></figure></p>
<p>查看TCP 掉包时的内核路径以推测掉包原因（TCP 掉包路径非常多，只能打印堆栈来诊断了）。</p>
<h2 id="步骤3（可选）-源码编译安装最新版BCC与BPFTrace"><a href="#步骤3（可选）-源码编译安装最新版BCC与BPFTrace" class="headerlink" title="步骤3（可选） 源码编译安装最新版BCC与BPFTrace"></a>步骤3（可选） 源码编译安装最新版BCC与BPFTrace</h2><p>默认的安装方式虽然简单但是所使用的工具版本比较老旧，为了体验最新功能可以下载最新代码并编译安装。需要提示的是<strong>以下操作都是在adeb shell中执行</strong>，也就是所有操作都在手机端完成，包括源码下载，编译与安装。</p>
<h3 id="安装BCC"><a href="#安装BCC" class="headerlink" title="安装BCC"></a>安装BCC</h3><ol>
<li>git clone <a href="https://github.com/iovisor/bcc.git" target="_blank" rel="noopener">https://github.com/iovisor/bcc.git</a>        // 下载bcc项目代码</li>
<li>cd bcc &amp;&amp; rm -rf build &amp;&amp; mkdir -p build &amp;&amp; cd build        //在bcc目录下创建build目录，用于代码编译。</li>
<li>export CC=clang-6.0        // 设置C编译器</li>
<li>export CXX=clang++-6.0        //设置C++编译器</li>
<li>cmake .. -DCMAKE_INSTALL_PREFIX=/usr        //运行环境检查</li>
<li>make -j4        //编译</li>
<li>make install        //安装</li>
</ol>
<p>安装后的tools路径为”/usr/share/bcc/tools”，运行cachestat检查下是否安装成功。</p>
<p>可能出现的错误：<br>BCC 20190129版本中运行上面命令时会出现如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;/usr/share/bcc/tools/cachestat&quot;, line 20, in &lt;module&gt;</span><br><span class="line">    from bcc import BPF</span><br><span class="line">  File &quot;/usr/lib/python2.7/dist-packages/bcc/__init__.py&quot;, line 30, in &lt;module&gt;</span><br><span class="line">    from .syscall import syscall_name</span><br><span class="line">  File &quot;/usr/lib/python2.7/dist-packages/bcc/syscall.py&quot;, line 387, in &lt;module&gt;</span><br><span class="line">    raise Exception(&quot;ausyscall: command not found&quot;)</span><br><span class="line">Exception: ausyscall: command not found</span><br></pre></td></tr></table></figure></p>
<p>解决方法：<br>安装auditd程序</p>
<blockquote>
<p>apt install auditd </p>
</blockquote>
<p>如果提示没有找到auditd命令的话，需要手动更新下source list。推荐将 “deb <a href="http://ftp.de.debian.org/debian" target="_blank" rel="noopener">http://ftp.de.debian.org/debian</a> stretch main” 添加到”/etc/apt/sources.list”文件后执行更新。</p>
<blockquote>
<p>apt update </p>
</blockquote>
<h3 id="安装-BPFTrace"><a href="#安装-BPFTrace" class="headerlink" title="安装 BPFTrace"></a>安装 BPFTrace</h3><ol>
<li>git clone <a href="https://github.com/iovisor/bpftrace.git" target="_blank" rel="noopener">https://github.com/iovisor/bpftrace.git</a>        // 下载bpftrace项目代码</li>
<li>cd bpftrace &amp;&amp; rm -rf build &amp;&amp; mkdir -p build &amp;&amp; cd build        //在bpftrace目录下创建build目录，用于代码编译。</li>
<li>export CC=clang-6.0        // 设置C编译器</li>
<li>export CXX=clang++-6.0        //设置C++编译器</li>
<li>cmake -DCMAKE_BUILD_TYPE=Debug ../        //运行环境检查</li>
<li>make -j4        //编译</li>
<li>make install        //安装</li>
</ol>
<p>可能出现的错误1：<br>无法找到”BPF_FUNC_get_current_cgroup_id”定义！</p>
<p>错误原因是我用的4.9内核中还没有这个定义，是commit 22110ad25b51b0e1f1ece4fcdf21a3738391f018中引入的功能。如果你的内核也是4.9，或者提示没有定义的话可以单笔回退这个提交。</p>
<blockquote>
<p>git revert 22110ad25b51b0e1f1ece4fcdf21a3738391f018</p>
</blockquote>
<p>可能出现的错误2：<br>无法找到”bpf_create_map”，是否使用”bcc_create<em>map”替代？<br>这是因为bpftrace依赖bcc的库函数，而这个库函数中使用的是bcc开头。规避办法是将bpf</em>相关调用修改成bcc_，修改如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/attached_probe.cpp b/src/attached_probe.cpp</span><br><span class="line">index 1837b6a..de9c6e0 100644</span><br><span class="line">--- a/src/attached_probe.cpp</span><br><span class="line">+++ b/src/attached_probe.cpp</span><br><span class="line">@@ -331,7 +331,7 @@ void AttachedProbe::load_prog()</span><br><span class="line">   for (int attempt=0; attempt&lt;3; attempt++)</span><br><span class="line">   &#123;</span><br><span class="line">-    progfd_ = bpf_prog_load(progtype(probe_.type), namep,</span><br><span class="line">+    progfd_ = bcc_prog_load(progtype(probe_.type), namep,</span><br><span class="line">         reinterpret_cast&lt;struct bpf_insn*&gt;(insns), prog_len, license,</span><br><span class="line">         kernel_version(attempt), log_level, log_buf, log_buf_size);</span><br><span class="line">     if (progfd_ &gt;= 0)</span><br><span class="line">diff --git a/src/map.cpp b/src/map.cpp</span><br><span class="line">index 5cfd442..6a452b4 100644</span><br><span class="line">--- a/src/map.cpp</span><br><span class="line">+++ b/src/map.cpp</span><br><span class="line">@@ -46,7 +46,7 @@ Map::Map(const std::string &amp;name, const SizedType &amp;type, const MapKey &amp;key, int</span><br><span class="line">   int value_size = type.size;</span><br><span class="line">   int flags = 0;</span><br><span class="line">-  mapfd_ = bpf_create_map(map_type, name.c_str(), key_size, value_size, max_entries, flags);</span><br><span class="line">+  mapfd_ = bcc_create_map(map_type, name.c_str(), key_size, value_size, max_entries, flags);</span><br><span class="line">   if (mapfd_ &lt; 0)</span><br><span class="line">   &#123;</span><br><span class="line">     std::cerr &lt;&lt; &quot;Error creating map: &apos;&quot; &lt;&lt; name_ &lt;&lt; &quot;&apos;&quot; &lt;&lt; std::endl;</span><br><span class="line">@@ -80,7 +80,7 @@ Map::Map(enum bpf_map_type map_type)</span><br><span class="line">     std::cerr &lt;&lt; &quot;invalid map type&quot; &lt;&lt; std::endl;</span><br><span class="line">     abort();</span><br><span class="line">   &#125;</span><br><span class="line">-  mapfd_ = bpf_create_map(map_type, name.c_str(), key_size, value_size, max_entries, flags);</span><br><span class="line">+  mapfd_ = bcc_create_map(map_type, name.c_str(), key_size, value_size, max_entries, flags);</span><br><span class="line">   if (mapfd_ &lt; 0)</span><br><span class="line">   &#123;</span><br></pre></td></tr></table></figure></p>
<p>安装后的tools路径为”/usr/local/share/bpftrace/tools”，运行如下命令验证安装结果：</p>
<blockquote>
<p>bpftrace -e ‘kprobe:do_nanosleep { printf(“PID %d sleeping…\n”, pid); }’</p>
</blockquote>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>本文介绍的方法适用于系统开发阶段，因为有了debian，所以只要能找到源或者代码，几乎可以执行任何linux 发行版上的工具。</li>
<li>后面会陆续介绍其他比较重要的工具（Perf，glances，pidstat，stress等），目前计划还是基于debian的方案。</li>
<li>用户固件中不可能会有这套debian的程序，因为他需要root运行，这是最大的缺点。个人比较认同的方案是4，也就是实现适合用于android 环境的类似BCC&amp;BPFTrace工具链，目标是用户固件中也可指直接使用eBPF。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li>“eBPF super powers on ARM64 and Android.pdf” by Joel Fernandes</li>
<li><a href="https://github.com/joelagnel/adeb/blob/master/README.md" target="_blank" rel="noopener">https://github.com/joelagnel/adeb/blob/master/README.md</a></li>
<li><a href="https://github.com/joelagnel/adeb/blob/master/BCC.md" target="_blank" rel="noopener">https://github.com/joelagnel/adeb/blob/master/BCC.md</a></li>
<li><a href="https://github.com/iovisor/bcc#tools" target="_blank" rel="noopener">https://github.com/iovisor/bcc#tools</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2019/01/28/eBPF架构优势及其应用方向上的畅想/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/28/eBPF架构优势及其应用方向上的畅想/" itemprop="url">eBPF架构优势及其应用方向上的畅想</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2019-01-28T17:37:51+08:00">
                2019-01-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="eBPF架构的优势"><a href="#eBPF架构的优势" class="headerlink" title="eBPF架构的优势"></a>eBPF架构的优势</h2><p>本文假设读者已了解以下内容：</p>
<ol>
<li>了解BPF/eBPF是什么，了解BPF的演变历史，可参考引用7。</li>
<li>了解程序的编译与执行流程，虚拟机工作原理。</li>
<li>大致了解Android系统架构以及开发流程。</li>
<li>本文是基于嵌入式Linux的开发角度阐述eBPF的应用，对负载情况及需求不一样的其他应用领域（如，云计划，后端服务器）可能不太适用，请读者注意区分。</li>
</ol>
<h3 id="eBPF功能的概括描述"><a href="#eBPF功能的概括描述" class="headerlink" title="eBPF功能的概括描述"></a>eBPF功能的概括描述</h3><p>概括讲，eBPF是一套调试框架，它允许当用户关心的事件发生时允许直接运行用户编写的代码。是不是感觉很熟悉？在Linux中早已存在的Ftrace，SystemTap，甚至Java中ASM技术都有类似的功能。在内核空间中执行到目标函数入口时执行用户事先定义好的代码，可以处理目标函数的入参数据。当目标函数执行完成后返回时也可以执行用户事先定义好的代码，对函数返回值做处理。</p>
<p>注意：eBPF可以通过USDT(User Statically-Defined Tracing)技术对用户空间程序做同样的效果，但因为本质上都是执行在内核空间所以不做过多区分。</p>
<p>对目标函数的处理流程，相比其他Profile工具而言没有特殊之处，抽象此流程为如下：</p>
<img src="/2019/01/28/eBPF架构优势及其应用方向上的畅想/ebpf_handler_works.png">
<p>但是在此执行流程基础上，eBPF的特殊之处在于：</p>
<ol>
<li>用户定义的回调函数及数据处理可以直接运行在内核空间。</li>
<li>用户的回调函数实现是动态执行的，也就是不参与内核或系统的编译，像Shell脚本一样即写即可得。</li>
<li>大一统了Linux目前主流的调试框架、如：Ftrace，Kprobe，Perf，USDT(User Statically-Defined Tracing)等。</li>
</ol>
<p>这三个特殊之处可了不得，它使的eBPF相比之前调试工具：</p>
<ol>
<li>目标函数数据的处理都执行在内核空间，这就省去了大量的用户与内核空间上的<strong>数据拷贝</strong>，<strong>系统调用</strong>，<strong>上下文切换</strong>等负载。性能强悍到甚至可以直接处理网络请求包(BPF是Berkeley Packet Filters的缩写而e代表Extended)，从他的名字就能猜到它就是为此而生。</li>
<li>因为用户回调函数是动态执行，大大提高了应用上的灵活性。遇到手头问题的时候，想查哪个状态随手一敲就能得到结果。</li>
<li>之前学习各类Linux上的调试工具时候总觉得东西好多而且好乱。eBPF使用了一套API统一了各种底层调试机制，套用互联网应用开发常说的话，”让程序员更专注在具体业务上”。</li>
</ol>
<h3 id="要是我的话该怎么设计？"><a href="#要是我的话该怎么设计？" class="headerlink" title="要是我的话该怎么设计？"></a>要是我的话该怎么设计？</h3><p>与eBPF类似的调试系统就是Dtrace，它主要应用在Solaris，MacOS上。Linux社区上也有多个分支版本，但始终没有合并到主干上。第一次初步了解eBPF的时候我也设想过如果要我设计类Dtrace的系统，应该怎么设计。假设我们将过程分为三步：</p>
<ol>
<li>事件发生时通知到调试系统</li>
<li>调试系统接到通知后在内核层执行用户注册的回调函数</li>
<li>用户代码不需要编译，可直接运行</li>
</ol>
<h4 id="1-事件发生时通知到调试系统"><a href="#1-事件发生时通知到调试系统" class="headerlink" title="1. 事件发生时通知到调试系统"></a>1. 事件发生时通知到调试系统</h4><p>首先想到就是复用ftrace接口，将原先访问/sys/kernel/debug/tracing操作接口转换成更为方便的API，可供用户层的回调函数使用。后来想到既然都是运行在内核层，不如把范围扩大一些。只要是带符号的内核函数，都可以当做目标函数供用户使用。对目标函数的寻址方法沿用类似Dtrace方案，也就是约定好命名规则。</p>
<h4 id="2-调试系统接到通知后在内核层执行用户注册的回调函数"><a href="#2-调试系统接到通知后在内核层执行用户注册的回调函数" class="headerlink" title="2. 调试系统接到通知后在内核层执行用户注册的回调函数"></a>2. 调试系统接到通知后在内核层执行用户注册的回调函数</h4><p>既然是可执行代码，那就需要编译。编译器将用户的回调函数直接编译成目标CPU架构的ELF文件后将ELF文件写入到内核的类似ioctl之类的系统调用上。这套理论上可行，但实际上问题很多。有一个难搞定的问题是用户函数可以通过指针操作，访问到内核的任何数据接口，这在安全性上是不可接受的。后来又看到Lua引擎运行在内核上的项目，是不是也可以参考此类架构，在Kernel中安插一个解释脚本引擎，如Lua，甚至简单版本的Java，Python之类。这个方案的不足之处在于，这类语言的编译器比较庞大，对内核来说一是代码不够统一，二是过于复杂容易造成安全漏洞。</p>
<h4 id="3-用户代码不需要编译，可直接运行"><a href="#3-用户代码不需要编译，可直接运行" class="headerlink" title="3. 用户代码不需要编译，可直接运行"></a>3. 用户代码不需要编译，可直接运行</h4><p>这条与第2条是本质上是同一个，为了支持动态执行，要么写入到内核之前编译好目标代码，要么由内核来直接解释执行。</p>
<h3 id="社区的实现方案"><a href="#社区的实现方案" class="headerlink" title="社区的实现方案"></a>社区的实现方案</h3><img src="/2019/01/28/eBPF架构优势及其应用方向上的畅想/ebpf_with_tool_chain.png">
<p>社区的实现相比我的初步设想优点不一样，而且更好更强大。</p>
<ul>
<li>首先，它统一了几乎所有内核现有的调试框架，ftrace，kproble都可以使用，甚至perf 事件，用户空间程序自定义事件也都没问题。编程接口上使用简单地规则定义了具体要监听哪种调试框架下的哪种事件，使用起来非常方便。</li>
<li>然后参照Java语言虚拟机方案，如下：<ul>
<li>先对Java语言通过编译器编译成优化好的Bytecode。</li>
<li>虚拟机对输入进来的Bytecode做例行检查后以解释执行或JIT执行。</li>
</ul>
</li>
<li>社区的方案是将Java语言替换成BPF语言，Java编译器替换成LLVM编译器，它生成出来的文件称为 BPF Bytecode。 </li>
<li>使用者把生成出来的Bytecode通过一个叫bpf()系统调用传递给内核，由内核虚拟机处理。</li>
<li>内核没有沿用任何已有的虚拟机，而是实现了一套简单，但是又能保证安全的虚拟机来执行BPF bytecode。它既不能大量的循环操作，也不能访问指定范围外的内核数据。这么做是为了保证内核安全以及回调程序的性能。因为它是执行在内核上下文，如果随便来个for(;;) {}岂不是分分钟把系统搞挂？ 这是绝对不允许的。格外需要说明的是BPF程序实际上可以执行循环语句，但数量有限。</li>
</ul>
<h2 id="有意思的eBPF工具栈"><a href="#有意思的eBPF工具栈" class="headerlink" title="有意思的eBPF工具栈"></a>有意思的eBPF工具栈</h2><p>经过上面讨论可知，我们需要用户空间运行的LLVM编译器，也需要跟内核打交道的处理程序（调用bpf()及相关命令），又要把eBPF返回的数据展示给用户。整个流程涉及的点比较多，可以手动编写代码来完成也可以使用社区正在开发的开源项目，BPFtrace及BCC。<br>如果想要了解eBPF整个流程的话，从简单地demo代码开始入手确是个好选择。请参考引用3项目，学习下最基础的eBPF流程是怎样的。BPFtrace，BCC其实都是这个demo程序的高阶版本，他们存在的目的无非是再封装一层，屏蔽了大量繁琐的细节之后让”让程序员更专注在具体业务上”。</p>
<h3 id="BPFTrace"><a href="#BPFTrace" class="headerlink" title="BPFTrace"></a>BPFTrace</h3><p>来几段所谓One liner的程序观赏一下（项目参考引用4）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># bpftrace -e &apos;tracepoint:syscalls:sys_enter_* &#123; @[probe] = count(); &#125;&apos;</span><br><span class="line">Attaching 320 probes...</span><br><span class="line">^C</span><br><span class="line">...</span><br><span class="line">@[tracepoint:syscalls:sys_enter_access]: 3291</span><br><span class="line">@[tracepoint:syscalls:sys_enter_close]: 3897</span><br><span class="line">@[tracepoint:syscalls:sys_enter_newstat]: 4268</span><br><span class="line">@[tracepoint:syscalls:sys_enter_open]: 4609</span><br><span class="line">@[tracepoint:syscalls:sys_enter_mmap]: 4781</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># bpftrace -e &apos;kprobe:do_sys_open &#123; printf(&quot;%s: %s\n&quot;, comm, str(arg1)) &#125;&apos;</span><br><span class="line">Attaching 1 probe...</span><br><span class="line">git: .git/objects/da</span><br><span class="line">git: .git/objects/pack</span><br><span class="line">git: /etc/localtime</span><br><span class="line">systemd-journal: /var/log/journal/72d0774c88dc4943ae3d34ac356125dd</span><br><span class="line">DNS Res~ver #15: /etc/hosts</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>
<p>是不是特别简单优美，即使没学过BPF语法一看就能懂。具体细节请参考BPFtrace项目文档，文档写的很全很详细。BPFTrace设计意图在于提供简单地编程方式实现对系统的调试。BPFTrace可以这么简洁的原因是他已经封装好了常用的函数以及程序行为，简单的代价是功能上有所割舍。适用于快速概念验证，调试探索阶段使用，更复杂功能还要看BCC。</p>
<h3 id="BCC-BPF-Compiler-Collection"><a href="#BCC-BPF-Compiler-Collection" class="headerlink" title="BCC(BPF Compiler Collection)"></a>BCC(BPF Compiler Collection)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> ./bitehist.py</span><br><span class="line">Tracing... Hit Ctrl-C to end.</span><br><span class="line">^C</span><br><span class="line">     kbytes          : count     distribution</span><br><span class="line">       0 -&gt; 1        : 3        |                                      |</span><br><span class="line">       2 -&gt; 3        : 0        |                                      |</span><br><span class="line">       4 -&gt; 7        : 211      |**********                            |</span><br><span class="line">       8 -&gt; 15       : 0        |                                      |</span><br><span class="line">      16 -&gt; 31       : 0        |                                      |</span><br><span class="line">      32 -&gt; 63       : 0        |                                      |</span><br><span class="line">      64 -&gt; 127      : 1        |                                      |</span><br><span class="line">     128 -&gt; 255      : 800      |**************************************|</span><br></pre></td></tr></table></figure>
<p>BCC的功能基本上BPFTrace类似，但是他呈现的方式不太一样（项目参考引用5），具体表现为：</p>
<ol>
<li>BCC中的工具虽然提供的功能跟BPFTrace一样，但是他能做更多的事情。不像BPFTrace简单一行代码，它是用Python代码实现的命令，在此程序中加载一个叫BCC的python程序包，在这个库中实现了对eBPF的所有封装。所有它可以利用Python以及庞大的工具库实现非常丰富的监控流程控制与结果展示，如：画图，统计，甚至对输出数据做机器学习训练。</li>
<li>在Python程序中需要以BPF语言实现回调函数，所以对eBPF行为的控制更佳细致及深入，具体参考Reference Guide（参考应用6）。</li>
<li>对eBPF返回的结果做更多的处理操作。</li>
</ol>
<p>总之如作者所说，简单需求使用BPFTrace，复杂需求使用BCC。</p>
<h2 id="eBPF在Android系统优化上的畅想"><a href="#eBPF在Android系统优化上的畅想" class="headerlink" title="eBPF在Android系统优化上的畅想"></a>eBPF在Android系统优化上的畅想</h2><p>BCC项目中提供了大量的调试小程序，在我看来这些其实是对历史性能调试工具的重新实现，是以更优雅的方式实现。eBPF更大的魅力在于他的高性能跟灵活性。灵活性体现在只要是编译好的bytecode内核可以直接执行，这在线上固件的调试上带来了极大的便利性。</p>
<h3 id="强悍的性能"><a href="#强悍的性能" class="headerlink" title="强悍的性能"></a>强悍的性能</h3><p>实现直接对用户版本的固件进行性能回归测试。之前为了达到同样的效果，要么直接对内核修改，要么开启大量调试功能并执行特殊的性能分析程序。 这会带来的一个麻烦问题是需要维护单独开发分支以免干扰用户主干分支，而且随着时间的迭代，代码基线会偏离于线上用户版本，后续维护成本很大。所以在CI/CD的落地过程中，系统固件部分的测试是工程实践难点。如果eBPF的高性能可以满足可接受范围内的性能损失，那完全可以直接拿线上版本做回归测试。</p>
<h3 id="虚拟机带来的灵活性"><a href="#虚拟机带来的灵活性" class="headerlink" title="虚拟机带来的灵活性"></a>虚拟机带来的灵活性</h3><p>实现针对线上用户的单点下发，以了解更多的用户实际使用的系统负载情况。了解真实用户的系统负载对改进系统设计来说帮助很大，他就像一个灯塔指示了优化方向及系统瓶颈点。但痛点是在用户版本固件中不敢开大量的调试功能用于收集系统运行状态，因为性能损耗非常大。在eBPF之后可以根据情况随时修改脚本，并做灰度测试用于收集相关运行指标，会大大加快整个优化流程。Android中的很多应用都热衷于热修复一样，不打扰用户的情况下修改线上程序的需求在系统开发时也是很有用的功能。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ol>
<li>随着软件技术的发展，调试机制也会不断发展，方向是朝着更具有框架性，更易于使用，更高性能为目标。不像之前那样，为了解决特定问题而设计，在完整性上提升了很多。</li>
<li>业务负载变复杂的同时，手上工具也需要越来越灵活多变，用以面对不停变化的局面。先进生产力，有一部分是体现在工具的使用上，好的工具可避免没必要的时间浪费，提升工作效率，将精力集中在更有挑战的事情上。 </li>
<li>随说软件轮子复用是好工程的指标之一，但从eBPF实现来看它借鉴了其他项目的好想法但实现上完全是另起炉灶。</li>
<li>软甲架构设计中，分层思路是万古不变的原则。</li>
<li>BCC在android上的应用实践请参考本博的博文<a href="http://www.caveman.work/2019/01/29/eBPF-on-Android/" target="_blank" rel="noopener">eBPF on Android</a></li>
</ol>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol>
<li><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="noopener">http://www.brendangregg.com/perf.html</a></li>
<li><a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#probes" target="_blank" rel="noopener">https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md#probes</a></li>
<li><a href="https://github.com/pratyushanand/learn-bpf" target="_blank" rel="noopener">https://github.com/pratyushanand/learn-bpf</a></li>
<li><a href="https://github.com/iovisor/bpftrace" target="_blank" rel="noopener">https://github.com/iovisor/bpftrace</a></li>
<li><a href="https://github.com/iovisor/bcc" target="_blank" rel="noopener">https://github.com/iovisor/bcc</a></li>
<li><a href="https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md" target="_blank" rel="noopener">https://github.com/iovisor/bcc/blob/master/docs/reference_guide.md</a></li>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-lo-eBPF-history/index.html</a> ; eBPF 简史</li>
<li><a href="http://www.caveman.work/2019/01/29/eBPF-on-Android/" target="_blank" rel="noopener">http://www.caveman.work/2019/01/29/eBPF-on-Android/</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2018/11/13/以Little-s-Law角度解读iostat输出的avgqu-sz-平均队列长度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/11/13/以Little-s-Law角度解读iostat输出的avgqu-sz-平均队列长度/" itemprop="url">以Little's Law角度解读iostat输出的avgqu-sz(平均队列长度)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-11-13T20:13:46+08:00">
                2018-11-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update: 20181213</em></p>
<p>之前在博文<a href="http://www.caveman.work/2018/05/20/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%AD%E7%A7%91%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99%EF%BC%88Little-s-Law%EF%BC%89%E4%B8%8E%E5%85%B6%E8%A1%8D%E7%94%9F%E6%B3%95%E5%88%99%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">性能分析中科特尔法则（Little’s Law）与其衍生法则的应用</a>有介绍过Little’s law合它的简单证明过程，但此文中并没有给出相应的应用实例。 本文通过以Little’s law角度解读iostat命令输出的avgqu-sz指标。</p>
<h2 id="查看平均队列长度"><a href="#查看平均队列长度" class="headerlink" title="查看平均队列长度"></a>查看平均队列长度</h2><p>最简单的方法是通过命令 iostat -x 1 以每隔一秒一次输出队列长度，如下图所示。<br><img src="/2018/11/13/以Little-s-Law角度解读iostat输出的avgqu-sz-平均队列长度/iostat_output.png"></p>
<p>红框所示的avgqu-sz就是平均队列长度了，这里直接引用博文 <a href="http://bean-li.github.io/dive-into-iostat/" target="_blank" rel="noopener">http://bean-li.github.io/dive-into-iostat/</a><br>中给出的计算方法。</p>
<blockquote>
<p>我们换一种思路来考虑，即diskstats中time_in_queue的思路。<br>当第一个IO完成的时候，队列中250个IO，250个IO都等了4ms，即time_in_queue + = (250<em>4) ，当第二个IO完成的时候，time_in_queue += (249</em>4)，当所有IO都完成的时候，time_in_queue = 4*(250+249+248….+1)， …<br>根据time_in_queue/1000,殊途同归地获得了平均队列长度。</p>
</blockquote>
<p>第一次读到这段解释时似懂非懂，后来想起来在证明Little’s Law的过程中曾使用面积的来替代队列中的总等待时间并除以观察时间得出平均队列长度。通过这个方法来理解iostat的计算队列长度会简单得多，而且有利于加深对Little’s Law的理解。</p>
<h2 id="借用Little’s-Law的证明思路"><a href="#借用Little’s-Law的证明思路" class="headerlink" title="借用Little’s Law的证明思路"></a>借用Little’s Law的证明思路</h2><p>我们回顾下Little’s law的证明过程，</p>
<blockquote>
<img src="/2018/11/13/以Little-s-Law角度解读iostat输出的avgqu-sz-平均队列长度/little_law_proof.png">
<p>Little’s law中不太好理解的参数是<strong>队列中平均任务数</strong>，请参考上图中的绿色部分A(T)。<strong>A(T)为T观察时间范围内，已经入队到队列中的所有任务等待时间的总和，也可以理解为绿色部分的面积。</strong>当由n(t)导致的不规则绿色区域抹平成长方形时，设T为长方形的宽，队列中的平均任务数为高，则A(T) = T * 队列中平均任务数。设L(T) = A(T) / T，则L(T)等同于平均等待任务数（也称为平均队列长度）。</p>
</blockquote>
<p>上面一段是博文”性能分析中科特尔法则（Little’s Law）与其衍生法则的应用”的片段。由于观察范围时间T可以由我们指定，那我们需要计算出绿色区域面积就可以得出平均队列长度。</p>
<p>那问题变成了我们怎么能获取队列中的所有任务的等待时间呢？<br>在Linux 内核（以4.4版本为例）中有如下代码，它在每次关键IO事件时会被调用。<br><img src="/2018/11/13/以Little-s-Law角度解读iostat输出的avgqu-sz-平均队列长度/part_round_stats.png"><br>其中time_in_queue就等同于上面所说的”入队到队列中的所有任务等待时间的总和”。<br>每当发生以下几个IO事件时会触发IO统计，也就是调用part_round_stats_single()。</p>
<ul>
<li>当有新的IO请求入队</li>
<li>当IO请求被已有请求合并(Front merge or Back merge)时</li>
<li>当完成某个IO请求时</li>
</ul>
<p>在博文 <a href="http://bean-li.github.io/dive-into-iostat/" target="_blank" rel="noopener">http://bean-li.github.io/dive-into-iostat/</a>中有提到Merge时不会做IO统计函数，但是在kernel 4.4中可以到由blk_queue_bio()函数根据情况分别会调用attempt_front_merge()或attempt_back_merge()。</p>
<p>每当发生关键IO事件；<strong>发起请求，完成请求，请求被合并</strong>时查看当前有几条正在执行的读请求IO或写请求IO，将此值乘以临近时间差就得出了系统当前处理IO时的总耗时。这与Little’ Law中通过面积来计算总耗时是一个道理，”绿色面积”中每当一个请求来的时候就上调一格，完成IO时就下调一格。在观察时间周期T内，以此方法来画出的绿色区域就是请求的总耗时时间。需要再次强调的关键概念是：</p>
<ul>
<li>系统同时可以有多个读请求</li>
<li>系统同时可以有多个写请求</li>
<li>读请求与写请求可以同时发生</li>
</ul>
<p>2：内核函数part_in_flight()中返回的IO数目也是读和写请求的总和。<br><img src="/2018/11/13/以Little-s-Law角度解读iostat输出的avgqu-sz-平均队列长度/part_in_flight.png"></p>
<h2 id="如何获取平均服务时间？"><a href="#如何获取平均服务时间？" class="headerlink" title="如何获取平均服务时间？"></a>如何获取平均服务时间？</h2><p>Linux的/proc/diskstat中目前(4.4版本)只提供了处理完成的IO请求数量与IO等待时间，并没有提供请求入队的IO请求数量。在”性能分析中科特尔法则（Little’s Law）与其衍生法则的应用”也提到过Utilization law，是指当资源使用率不超过100%时可认为抵达率与完成率是一致的，这也意味着当资源使用率未达到100%时可以通过完成率替代抵达率以计算服务平均处理时间。iostat中用的方法也是利用了这一点，但本质上是Utilization law在发挥作用。如果遇到资源使用率达到性能拐点处时就已经不是job flow balance状态了（出现排队）。以严谨起见，最好是能获取到真正的请求入队数量，这样可以套用Little’s law计算出真正的平均服务时间。目前想到的唯一方法是通过修改内核代码以获取入队请求次数。</p>
<blockquote>
<p>W = L / λ </p>
</blockquote>
<p>补充：</p>
<p>当谈到Disk IO的服务时间时注意区分两种情况：</p>
<ul>
<li>IO队列服务时间 = 磁盘忙于IO请求的时间 + IO请求在队列中等待时间</li>
<li>磁盘IO服务时间 = 磁盘忙于IO请求的时间</li>
</ul>
<p>Little’s Law给出的平均服务时间是指IO队列服务时间，他是包括了队列中的等待时间。那实践中以哪个指标为主呢？我觉得是根据应用场景不同而不同，</p>
<ul>
<li>分析某个workload characterization 时会侧重看IO队列服务时间</li>
<li>分析某个设备整体情况时会侧重看磁盘IO服务时间。基于Flash的存储设备出现严重的文件碎片化时此值会暴增。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://bean-li.github.io/dive-into-iostat/" target="_blank" rel="noopener">http://bean-li.github.io/dive-into-iostat/</a></li>
<li><a href="http://www.caveman.work/2018/05/20/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%AD%E7%A7%91%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99%EF%BC%88Little-s-Law%EF%BC%89%E4%B8%8E%E5%85%B6%E8%A1%8D%E7%94%9F%E6%B3%95%E5%88%99%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">性能分析中科特尔法则（Little’s Law）与其衍生法则的应用</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2018/10/06/Android-UX-performance-check-list/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/10/06/Android-UX-performance-check-list/" itemprop="url">Android UX performance check list</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-10-06T17:27:53+08:00">
                2018-10-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update 20181006</em></p>
<h1 id="UX性能检查清单"><a href="#UX性能检查清单" class="headerlink" title="UX性能检查清单"></a>UX性能检查清单</h1><p>Android设备的用户体验性能包括：</p>
<ul>
<li>界面流畅度优化<ul>
<li>游戏类应用</li>
<li>普通用户交互类应用 如：社交APP，购物APP</li>
</ul>
</li>
<li>界面响应速度</li>
<li>更多场景待补充</li>
</ul>
<p>本文通过系统化的检查清单，以流程化的方式排查UX性能问题。<strong>随着对系统认识的加深与改变，清单内容也会跟着改变。</strong></p>
<p>首先，我们将Android系统以如下方式划分：<br><img src="/2018/10/06/Android-UX-performance-check-list/Stack.png"></p>
<p>将整个栈分为5层，4层软件+1层硬件。每一层由<strong>排查方向(Orientation)</strong>与<strong>排查工具(Diagnose Tools)</strong>组成。检查清单的作用在于以流程化的方式避免了不必要的时间浪费，清单方法看起来比较慢（或者”笨”），但在实际中它是最快，最完整的问题解决方法。所以本文注意力将放在清单的完备性上，与具体模块相关的内容（排查方向与工具使用）将在后续的文章中做详细介绍。</p>
<p>清单说明：</p>
<ul>
<li>Application与Frameworks是运行在应用程序上下文中。</li>
<li>Core Services是指Android关键服务，它配合LinuxKernel支持Android应用程序的运行。</li>
<li>检查顺序是从<strong>层1 Application 开始</strong>，按编号顺序检查。</li>
</ul>
<h1 id="层1-Application"><a href="#层1-Application" class="headerlink" title="[层1 Application]"></a>[层1 Application]</h1><img src="/2018/10/06/Android-UX-performance-check-list/Application.png">
<h1 id="层2-Frameworks"><a href="#层2-Frameworks" class="headerlink" title="[层2 Frameworks]"></a>[层2 Frameworks]</h1><img src="/2018/10/06/Android-UX-performance-check-list/Frameworks.png">
<h1 id="层3-Core-services"><a href="#层3-Core-services" class="headerlink" title="[层3 Core services]"></a>[层3 Core services]</h1><img src="/2018/10/06/Android-UX-performance-check-list/CoreServices.png">
<h1 id="层4-Linux-kernel"><a href="#层4-Linux-kernel" class="headerlink" title="[层4 Linux kernel]"></a>[层4 Linux kernel]</h1><img src="/2018/10/06/Android-UX-performance-check-list/LinuxKernel.png">
<h1 id="层5-Chips"><a href="#层5-Chips" class="headerlink" title="[层5 Chips]"></a>[层5 Chips]</h1><img src="/2018/10/06/Android-UX-performance-check-list/Chips.png">
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2018/08/17/CorrelationAnalysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/17/CorrelationAnalysis/" itemprop="url">TimeSeries关联性分析的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-17T16:31:37+08:00">
                2018-08-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update: 20180828</em></p>
<h2 id="什么是TimeSeries关联性分析（Correlation-Analysis）"><a href="#什么是TimeSeries关联性分析（Correlation-Analysis）" class="headerlink" title="什么是TimeSeries关联性分析（Correlation Analysis）"></a>什么是TimeSeries关联性分析（Correlation Analysis）</h2><p>假设有基于时间序列采集的两组同样大小的数据，关联性分析是指<strong>量化这两组数据间的关联程度</strong>。再次强调一下，本文中讨论的关联性分析是针对TimeSeries数据类型的，在自然语言处理中用到的关联性分析方法是基于信息熵，与文本中讨论的方法不相同，虽然他们都属于关联性分析。</p>
<ul>
<li>如果数据A上涨时，数据B上涨（同样适应于下跌的情况）则说明这两组数据有关联性，表示为正向关联。 </li>
<li>如果数据A上涨时，数据B下跌则说明这两组数据有关联性，表示为反向关联。</li>
<li>关联程度取决于两组数据间的变化幅度。</li>
</ul>
<h2 id="为什么要做关联性分析"><a href="#为什么要做关联性分析" class="headerlink" title="为什么要做关联性分析"></a>为什么要做关联性分析</h2><p>包括但不限于：</p>
<ul>
<li>使用聚类算法定位性能瓶颈。</li>
<li>结合数据可视化，进行信息挖掘。</li>
<li>根因分析。</li>
</ul>
<p>实践中比较实用的用法是分析某个指标的变动会引起哪类其他指标的变动。比如可以回答如下问题：</p>
<ul>
<li>Memory Cached与Memory Free间是什么关系？关联程度如何？</li>
<li>IO WriteBack频繁程度与哪种指标有关联？</li>
</ul>
<p>在设计系统资源调度策略与参数配置上，这类信息有助于系统最优设计。当优化某个关键指标时，需要查看与其关联的其他指标以确保不会出现指标失衡情况（改善一个指标时导致另一个指标的恶化）。通过此方法还可以分析出设备的硬件配置在运行用户负载程序时它的主要瓶颈是什么，针对不同资源瓶颈，配置不同的资源调度参数以实现能效的最优化。</p>
<h2 id="常用算法之-Pearson-Correlation-Coefficient"><a href="#常用算法之-Pearson-Correlation-Coefficient" class="headerlink" title="常用算法之 - Pearson Correlation Coefficient"></a>常用算法之 - Pearson Correlation Coefficient</h2><p>公式 - 来自Wikipedia<br><img src="/2018/08/17/CorrelationAnalysis/Pearson_Formula.png"></p>
<ul>
<li>Python Code:  Scipy.stats.pearson()</li>
<li>取值范围: [-1.0 ~ 1.0]</li>
</ul>
<p>使用Pearson时的注意点如下：</p>
<ul>
<li>函数结果的绝对值越接近1.0则关联性越强，越趋近于0.0则表明没有关联性。</li>
<li>两组数据间需要有独立性。</li>
<li>样本间需要有线性关系。</li>
</ul>
<h2 id="常用算法之-Spearman-Rank-Correlation-Coefficient"><a href="#常用算法之-Spearman-Rank-Correlation-Coefficient" class="headerlink" title="常用算法之 - Spearman Rank Correlation Coefficient"></a>常用算法之 - Spearman Rank Correlation Coefficient</h2><p>公式 - 来自Wikipedia<br><img src="/2018/08/17/CorrelationAnalysis/Spearman_Formula.png"></p>
<ul>
<li>Python Code: Scipy.stats.spearmanr() </li>
<li>取值范围: [-1.0 ~ 1.0]</li>
</ul>
<p>使用Spearman时的注意点如下：</p>
<ul>
<li>函数结果的绝对值越接近1.0则关联性越强，越趋近于0.0则表明没有关联性。</li>
<li>两组数据间需要有独立性。</li>
<li>样本间不止线性关系，满足单调关系时也适用。</li>
</ul>
<p>不过从实际表现来看，Pearson与Spearman不需要严格的遵从关系函数（线性，单调）。<br><img src="/2018/08/17/CorrelationAnalysis/PCC_vs_SCC.png"></p>
<h2 id="常用算法之-Normalized-Cross-Correlation"><a href="#常用算法之-Normalized-Cross-Correlation" class="headerlink" title="常用算法之 - Normalized Cross-Correlation"></a>常用算法之 - Normalized Cross-Correlation</h2><p>公式 - 来自Anomaly.io<br><img src="/2018/08/17/CorrelationAnalysis/NCC_Formula.png"></p>
<ul>
<li>函数结果的绝对值越接近1.0则关联性越强，越趋近于0.0则表明没有关联性。</li>
<li>抗异常值的干扰能力较强，这也意味着肉眼上看不是很明显的关联关系使用NCC计算时得分是比较高的。</li>
<li>NCC适合量化两组数据间的数值上的浮动程度（波动）。</li>
</ul>
<img src="/2018/08/17/CorrelationAnalysis/NCC_performance.png">
<p>从PCC与SCC的结果上看两组数据没有明显的关联性，但从NCC上看是有较强关系的。从肉眼上分析，两组数据间有较强的”贴合”关系，但不具备明显的关联性关系。</p>
<h2 id="两种关系"><a href="#两种关系" class="headerlink" title="两种关系"></a>两种关系</h2><p>将不同指标间的关联性属性划分为：</p>
<ul>
<li>直接关系（Direct Correlation）</li>
<li>间接关系（Indirect Correlation）</li>
</ul>
<p>直接关系是指两个metric间有正向关联或反向关联，总之是有某种的直接关联。间接关系是指两个metric间通过某种逻辑关系关联在一起且数值的变化可能不是实时的，会有一段时间的延迟。需要特殊说明的是，严格意义上来说在一个系统中的任意两个指标都会有关联关系，区别在于关联关系强弱与时效性。</p>
<h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p>Memory Free与Memory Cached间的对比<br><img src="/2018/08/17/CorrelationAnalysis/MemFree_MemCached.png"></p>
<ul>
<li>NCC较高但Pearson与Spearman给出的低分来看，这两个指标在这段时间内属于间接关联。</li>
<li>从free与cached回收原理上看，两个虽然有关系但并不是直接关系。这个依赖具体的PageCache 与Memory Reclaim算法。</li>
</ul>
<p>Memory Buffers与Memory Cached间的对比<br><img src="/2018/08/17/CorrelationAnalysis/MemBuffers_MemCached.png"></p>
<ul>
<li>Pearson与Spearman都给出0.5以上的分，说明两者有一些直接关系，只是强度不是很大。</li>
<li>从buffers与cached回收原理上看，两者其实都算是PageCache缓存。当遇到内存吃紧，IO 回写情景时两个buffer都会受到影响。</li>
</ul>
<p>Memory Free与 UX FrameDrop间的对比<br><img src="/2018/08/17/CorrelationAnalysis/UXFrameDrop_MemoryFree.png"></p>
<ul>
<li>Pearson与Spearman给出的分数来看，两个指标属于间接关系。</li>
<li>从原理上看低内存有可能会引起前台UX应用的卡顿，但这两者间并不具备直接关系。</li>
</ul>
<p>这里只给出了某个设备在某个时段的信息，而且还只是某个特定UX应用的关联性分析。在实际中，不同UX应用针对不同的metric间的关联性是不同的。比如有些应用是Memory sensitive，而有些是IO sensitive。只有经过大量数据（不同时段）的计算后才能给出较为准确的结论。</p>
<h2 id="其他常见的关联性分析算法，根据特性适用于不同领域。"><a href="#其他常见的关联性分析算法，根据特性适用于不同领域。" class="headerlink" title="其他常见的关联性分析算法，根据特性适用于不同领域。"></a>其他常见的关联性分析算法，根据特性适用于不同领域。</h2><ul>
<li>Apriori/FP Growth(Tree): 经典的超市关联分析中用到的算法。在多个异常指标的聚类时，也可以用此算法做初步筛查。</li>
<li>Canonical Correlation Analysis </li>
<li>Maximum Information Coeffcient</li>
<li>Kendall Correlation Coefficient</li>
<li>Euclidean distance</li>
<li>Mutual Information</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>这个世界很复杂，无法用一个指标或者量化方法理解所有现象。</li>
<li>使用指标时应根据现实数据情况采用不同的量化指标。</li>
<li>先采用数据可视化的方式观察下数据间的大致关系，之后根据其结果选择合适的量化指标。</li>
<li>数据可视化工具中可以同时展示关联性指标的计算结果，有助于数据解读。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/Pearson_correlation_coefficient" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Pearson_correlation_coefficient</a></li>
<li><a href="https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient</a></li>
<li><a href="https://anomaly.io/understand-auto-cross-correlation-normalized-shift/" target="_blank" rel="noopener">https://anomaly.io/understand-auto-cross-correlation-normalized-shift/</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2018/07/25/应用程序界面流畅度的量化方法与应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/应用程序界面流畅度的量化方法与应用/" itemprop="url">应用程序界面流畅度的量化方法与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-25T17:24:35+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update: 20180725</em></p>
<h2 id="指标与现实不匹配"><a href="#指标与现实不匹配" class="headerlink" title="指标与现实不匹配"></a>指标与现实不匹配</h2><p>应用流畅度是我们最关心的性能优化指标之一，本文主要介绍流畅度指标的理解与实际应用。<br>流畅度评判的难度在于量化指标并不能完全对应到感官体验上。 </p>
<p>这什么意思呢？ 举个简单例子；</p>
<p>假设有一个过场动画，从FPS，FrameUpdate等指标来看都是满分的，也就是FPS = 60， FrameUpdate &lt;= 16ms。<br>但从观感来看动画不是”够”流畅，过程中有顿挫感。更有意思的是，因为它是主观感受，所以其结论也是因人而异。</p>
<h2 id="优化效果的验证方法"><a href="#优化效果的验证方法" class="headerlink" title="优化效果的验证方法"></a>优化效果的验证方法</h2><p>验证优化效果的流程可拆分为如下：</p>
<img src="/2018/07/25/应用程序界面流畅度的量化方法与应用/phase_of_verifing_code_build.png">
<ul>
<li>Code Build：编译出来的程序</li>
<li>Verify in Lab：由实验室环境下由人使用测试用例验证</li>
<li>CI by Robot：程序由可持续集成框架(CI: Continuous Integration)进行自动化性能测试</li>
<li>Monitor in RUM：使用大数据工具分析线上用户数据在真实环境下的数据</li>
</ul>
<p>我们推荐的做法是：</p>
<ul>
<li>将<strong>定性方法(Qualitative method)</strong>应用在 [Verify in Lab]。</li>
<li>将<strong>定量方法(Quantitative method)</strong>应用在 [CI by Robot]，[Monitor in RUM]。</li>
</ul>
<h2 id="定性方法-Qualitative-method"><a href="#定性方法-Qualitative-method" class="headerlink" title="定性方法 (Qualitative method)"></a>定性方法 (Qualitative method)</h2><p>由于有些人对应用流畅度感受不够敏感，可以由对其比较敏感，在意的人员来操作。流畅度测试与其他测试不同，他需要<br>测试人员的对卡顿现象(界面更新不自然)的有与生俱来的感觉与挑剔。 拥有这种品质的人是定性测试的最佳人选。</p>
<h2 id="定量方法-Quantitative-method"><a href="#定量方法-Quantitative-method" class="headerlink" title="定量方法 (Quantitative method)"></a>定量方法 (Quantitative method)</h2><p>针对流畅度量化方法，我们的解决方案是不同界面场景使用不同的量化指标。</p>
<p><strong>常见应用场景：</strong></p>
<ul>
<li>流媒体，视频播放，相机类</li>
<li>游戏类</li>
<li>UX应用-内容浏览类</li>
<li>UX应用-内容交互类</li>
</ul>
<p><strong>流畅度量化指标：</strong></p>
<ul>
<li>FPS Family <ul>
<li>Realtime FPS</li>
<li>Static FPS</li>
<li>FPS Stability</li>
</ul>
</li>
<li>Frame Drop Family<ul>
<li>Frame Drop Percent       (FDP)</li>
<li>Frame Drop Badass        (FDB)</li>
<li>Frame Drop Heavy Tail  (FDHT)</li>
</ul>
</li>
<li>Heavy task in UI Thread (HT)</li>
</ul>
<p><strong>应用场景与量化指标间的使用关系为：</strong></p>
<ul>
<li>[流媒体，视频播放，相机类}  -&gt; [FPS Familiy]</li>
<li>[游戏类]                                  -&gt; [FPS Family]</li>
<li>[UX应用-内容浏览类]             -&gt; [FDP, FDB, HT]</li>
<li>[UX应用-内容交互类]             -&gt; [FDHT, HT]</li>
</ul>
<p><strong>待办项：</strong></p>
<ul>
<li>量化指标三大类具体计算方法?</li>
<li>场景与量化方法间匹配原则?</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li>Web Performance: Leveraging the Metrics that Most Affect User Experience (Google I/O ‘17)</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/" itemprop="url">通过Responsive Time Law理解性能拐点(Knee Of The Curve)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-07-01T00:41:54+08:00">
                2018-07-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update: 20180703</em></p>
<p>性能分析中除了Little’s law之外 Responsive time law（以下简称为RTL） 也是常用到的公式。RTL的最大贡献是量化了资源使用率与响应时间间的关系。性能分析领域中有个著名的点，叫”性能拐点(Knee of the cureve)”，本文讨论我关于这个点的几个思考。通过RTL公式可以看到当资源使用率超过某个点时响应时间会暴涨，这会引申出三个思考点：</p>
<ul>
<li>RTL公式究竟长成什么样？</li>
<li>性能拐点的定义是什么？</li>
<li>性能拐点的应用</li>
</ul>
<h2 id="RTL公式究竟长成什么样？"><a href="#RTL公式究竟长成什么样？" class="headerlink" title="RTL公式究竟长成什么样？"></a>RTL公式究竟长成什么样？</h2><p>RTL公式是通过Erlang C推导而来的，而Erlang C是用于描述排队论中任务被阻塞等待的概率。RTL公式目前只适用于符合M/M/c排队模型的队列。M/M/c是什么意思呢？他是Kendal notaion，具体意义为：</p>
<ul>
<li>M：请求到达的时间间隔呈现为指数分布，平均到达请求数量呈泊松分布。</li>
<li>M：服务时间分布呈指数分布。</li>
<li>c：服务数量 1为队列中只有一个server，2为有两个server。</li>
</ul>
<p>当队列满足M/M/c模型时计算响应时间公式为：</p>
<img src="/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/mmc_responsive_time_law.png">
<blockquote>
<p>响应时间 = 队列等待时间 + 服务时间<br>函数参数 c为server数量，p为资源使用率。</p>
</blockquote>
<p>使用Erlang C函数展开队列等待时间为：</p>
<img src="/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/wait_time_by_erlang_c.png">
<p>这里给出的是最终的结果，使用ErlangC推导整个等待队列时间比较复杂故此省略了。<br><a href="https://www.callcentrehelper.com/erlang-c-formula-example-121281.htm" target="_blank" rel="noopener">Erlang在1917年</a>通过泊松概率分布推导出了Erlang C公式，用于量化当时电信业务。需要注意的是使用Erlang C计算RTL时服务请求与服务处理时间需要满足各自的概率分布，也就是指数分布与泊松分布，而且要求每个请求间是相互独立，互不依赖。</p>
<p>另外值得一提的是网上还有一种简化版的RTL公式：</p>
<img src="/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/simple_responsive_time_law.png">
<blockquote>
<p>m 为服务数量，与上一个公式中的c相同。</p>
</blockquote>
<p>这个公式在m满足&lt;=2时与使用Erlang C的版本在结果上是一致的，但是当m超过2时精度没有比使用Erlang版本的高。简化版公式的意义在于可以通过心算的方式大致估摸出结果，再者就是减少计算量。但为了准确性，在这里还是推荐Erlang版本（毕竟这点计算量在现代处理器上是不叫事儿了）。</p>
<img src="/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/simple_rtl_vs_erlang_c.png">
<p>当c = 8，绿色为Erlang版本，紫色为简化版，从肉眼上可以看到简化版比较消极一些。从严谨的意义来说，这会使我们误认为系统性能相比实际情况好一些。</p>
<h2 id="性能拐点的定义是什么？"><a href="#性能拐点的定义是什么？" class="headerlink" title="性能拐点的定义是什么？"></a>性能拐点的定义是什么？</h2><img src="/2018/07/01/通过Responsive-Time-Law理解性能拐点-Knee-Of-The-Curve/knee_looks_like.png">
<p>从上面<a href="https://www.desmos.com/calculator/hsdmkbmvoa" target="_blank" rel="noopener">曲线</a>中可以看出越是接近1，响应时间（y轴）上升坡度越陡峭。曲线中存在某个点(资源使用率)，超过这个点时响应时间会暴涨，我们称呼他为<strong>Knee of the curve</strong>。那Knee的具体定义是什么样的呢？我查阅相关资料时发现有多种不同的定义；</p>
<ol>
<li>使用率达到75%的点为Knee。</li>
<li>有一条直线，穿过原点并与曲线交接的点为Knee。</li>
<li>响应时间为服务时间的2倍的点为Knee。</li>
</ol>
<p>可以明显的看出定义1是不够准确的，因为从曲线中看出随着server的数量（c）的增大曲线的陡峭是越往后移的。如果设75%为Knee点，在多Server的队列中会浪费硬件资源。定义2是从数学角度得出的Knee，这在实际业务中的实际应用效果有待观察。定义3是根据业务的需求得出的定义，比如有些业务严格要求响应时间不能超过服务时间的两倍，但有些又可以容忍到三倍。</p>
<p>所以总结来看，RTL曲线虽然可以提示我们随着使用量的增大，响应时间以类似曲棍球杆的形状陡峭增长，但具体从哪个Knee点开始性能变差且不可接受是没有标准答案的。因为，它依赖具体的业务，依赖你的客户容忍度，依赖你的硬件成本，依赖你的软件架构。</p>
<p>读者可以通过点此<a href="https://www.desmos.com/calculator/ojabuwirxq" target="_blank" rel="noopener">曲线</a>来观察下不同的c与S变量下曲线的变化程度。</p>
<h2 id="性能拐点的应用"><a href="#性能拐点的应用" class="headerlink" title="性能拐点的应用"></a>性能拐点的应用</h2><p>既然无法得出具体的Knee点定义，那我们怎么利用好它呢？通过以下两个角度来思考</p>
<ul>
<li>资源使用率</li>
<li>响应时间的容忍值</li>
</ul>
<h3 id="资源使用率的思考："><a href="#资源使用率的思考：" class="headerlink" title="资源使用率的思考："></a>资源使用率的思考：</h3><ul>
<li>业务是批处理时：可以100%资源使用，因为此时尽可能榨干硬件性能是有利于资源利用。</li>
<li>业务是与用户的交互场景时：资源率使用不宜超过Knee，当然这时根据业务需要定义Knee点。</li>
<li>业务是批处理与用户交互场景的混合型时：<ul>
<li>区分出前台与后台任务</li>
<li>通过Resource Control方法设置前后台各自的资源使用率上限 e.g. cpuset, cgroup</li>
<li>当用户交互时提高前台资源的预留比例并限制后台任务请求。</li>
</ul>
</li>
</ul>
<h3 id="响应时间的容忍值的思考："><a href="#响应时间的容忍值的思考：" class="headerlink" title="响应时间的容忍值的思考："></a>响应时间的容忍值的思考：</h3><ul>
<li>通过降低服务时间以尽可能降低响应时间</li>
<li>控制任务抵达率；从Utilization Law可知当任务抵达率提高时资源使用率也会提高，参考: <a href="http://www.caveman.work/2018/05/20/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E4%B8%AD%E7%A7%91%E7%89%B9%E5%B0%94%E6%B3%95%E5%88%99%EF%BC%88Little-s-Law%EF%BC%89%E4%B8%8E%E5%85%B6%E8%A1%8D%E7%94%9F%E6%B3%95%E5%88%99%E7%9A%84%E5%BA%94%E7%94%A8/" target="_blank" rel="noopener">性能分析中科特尔法则（Little’s Law）与其衍生法则的应用</a>。</li>
<li>项目规划时把Performance定义到Feature级别，并根据业务情况定义响应时间的可接受范围，参考: <a href="http://www.caveman.work/2018/01/18/CavemeWork-Analyzer%E4%B8%AD%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%A8%E7%A4%BA%E6%96%B9%E5%BC%8F/" target="_blank" rel="noopener">使用置信区间量化应用程序启动时间</a>。</li>
<li>Knee点根据响应时间可接受范围来定义，然后通过减少服务时间，控制资源使用率来满足业务要求。</li>
</ul>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>概率统计是一门非常有意思的学科，将其利用到性能数据分析上是未来学习方向之一。</li>
<li>除了数据可视化之外，函数可视化也能提供不少线索。本文中使用的曲线由desmos.com生成，推荐给各位。</li>
<li>性能分析时不要相信自己的直觉，一定要通过<strong>[数据收集 -&gt; 建模 -&gt; 量化结果]</strong>的方法来验证效果。</li>
</ul>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul>
<li><a href="https://en.wikipedia.org/wiki/M/M/c_queue" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/M/M/c_queue</a> </li>
<li><a href="https://en.wikipedia.org/wiki/Erlang_(unit)#Erlang_C_formula" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Erlang_(unit)#Erlang_C_formula</a></li>
<li><a href="https://www.xaprb.com/blog/response-time-stretch-factor/" target="_blank" rel="noopener">https://www.xaprb.com/blog/response-time-stretch-factor/</a></li>
<li><a href="http://blog.sina.com.cn/s/blog_5fe911250100dv3v.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_5fe911250100dv3v.html</a></li>
<li><a href="http://www.mitan.co.uk/erlang/elgcspsh.htm" target="_blank" rel="noopener">http://www.mitan.co.uk/erlang/elgcspsh.htm</a></li>
<li>Forecasting Oracle Performane by Craig Shallahamer ISBN-10: 1-59059-802-4</li>
<li>Optimizing-Oracle-Performance by Cary Millsap, Jeff Holt ISBN-10: 059600527X</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://caveman.work/2018/05/20/性能分析中科特尔法则（Little-s-Law）与其衍生法则的应用/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Caveman.Work">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Caveman.Work Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/20/性能分析中科特尔法则（Little-s-Law）与其衍生法则的应用/" itemprop="url">性能分析中科特尔法则（Little's Law）与其衍生法则的应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-20T15:58:29+08:00">
                2018-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>Last update: 20181112</em></p>
<h2 id="科特尔法则-Little’s-Law"><a href="#科特尔法则-Little’s-Law" class="headerlink" title="科特尔法则 Little’s Law"></a>科特尔法则 Little’s Law</h2><p>科特尔法则(Little’s Law)是John Little教授在1961证明并以他的名字命名的公式。Little’s Law是排队论中的重要公式，因现实世界中排队模型的应用非常广泛这也意味着此公式的应用也非常广泛。在性能分析中我们通过Little’s Law定位性能瓶颈，用模型预测随负载增加对业务性能的影响，以及通过容量规划提前为业务扩张做准备。在现实生活中凡是排队等待的情况都可以通过Little’s Law进行量化与优化（如银行，医院的排队取号）。</p>
<p>Little’s Law通过一个简单的公式<strong>量化了吞吐率与服务时间及等待队列长度三者之间的关系</strong>，简单公式的背后隐藏着巨大的信息量。<br>本文以最简单的排队模型介绍Little’s Law，如下图所示：</p>
<img src="/2018/05/20/性能分析中科特尔法则（Little-s-Law）与其衍生法则的应用/queue_system.png">
<blockquote>
<p>假设存在一个系统由单输入与单输出单元组成并且只有一个处理单元。当输入到系统中的请求速度快于处理单元处理速度时系统会出现排队等待情况。</p>
</blockquote>
<h3 id="Little’s-Law-公式"><a href="#Little’s-Law-公式" class="headerlink" title="Little’s Law 公式"></a>Little’s Law 公式</h3><p>$$L= λ * W$$</p>
<blockquote>
<p>队列中平均任务数 = 平均任务抵达率 * 平均任务处理时间(含队列等待时间)</p>
</blockquote>
<img src="/2018/05/20/性能分析中科特尔法则（Little-s-Law）与其衍生法则的应用/little_law_proof.png">
<p>Little’s law中不太好理解的参数是<strong>队列中平均任务数</strong>，请参考上图中的绿色部分A(T)。<strong>A(T)为T观察时间范围内，已经入队到队列中的所有任务等待时间的总和，也可以理解为绿色部分的面积。</strong>当由n(t)导致的不规则绿色区域抹平成长方形时，设T为长方形的宽，队列中的平均任务数为高，则A(T) = T * 队列中平均任务数。设L(T) = A(T) / T，则L(T)等同于平均等待任务数（也称为平均队列长度）。</p>
<p>公式注解：</p>
<ul>
<li>Little’s law的应用场景非常广泛，它既可以解释单一的系统部件（磁盘，CPU）也可以解释由多个子系统组成的复杂系统（网页界面响应时间）。</li>
<li>当平均队列长度变大时请求抵达率也会随着变大。只有系统待要处理的任务变多时才有可能使系统以最高吞吐率模式工作并榨干硬件性能，但他的反面是系统中入队等待任务变多，如果这个任务是跟用户体验相关时会表现为操作响应时间的变长（参见下面的响应时间部分内容）。</li>
<li>系统处理单元的平均服务时间变长时会导致等待队列的变长，优化等待队列长度的方向有：<ul>
<li>缩短平均服务时间</li>
<li>减少任务请求量</li>
</ul>
</li>
<li>本文介绍的是单一处理模型，如涉及多个并行处理模型时优化方法不止上面两种。</li>
</ul>
<h2 id="Little’s-Law-衍生应用-Utilization-Law-使用率的计算"><a href="#Little’s-Law-衍生应用-Utilization-Law-使用率的计算" class="headerlink" title="Little’s Law 衍生应用 - Utilization Law 使用率的计算"></a>Little’s Law 衍生应用 - Utilization Law 使用率的计算</h2><h3 id="Utilization-Law-公式"><a href="#Utilization-Law-公式" class="headerlink" title="Utilization Law 公式"></a>Utilization Law 公式</h3><p>$$U = X * St$$</p>
<blockquote>
<p>使用率 = 吞吐率 * 服务处理时间</p>
</blockquote>
<p>当使用率不超过100%时Utlization law其实是little’s Law的一个变种，这种情况被称为<strong>Job flow balance（此时抵达率与吞吐率相同）</strong>。</p>
<p>公式注解：</p>
<ul>
<li>吞吐率不变的情况下服务处理时间的提升导致使用率的提升。</li>
<li>在使用率不变的前提下要使吞吐率上升需要缩短服务处理时间。</li>
</ul>
<p>在磁盘性能老化分析时有时候会遇到磁盘使用率变化不大但磁盘吞吐率反而降低了。这是因为老化（磁盘长时间使用后）后的磁盘可能会出现文件碎片化。在读取以碎片化形式存储在磁盘各个地方的文件时可能会加长磁盘寻道时间（物理磁头转动时间），这个操作会体现在磁盘服务处理时间上，通过公式可知此时磁盘使用率变化不大但因处理服务时间变长导致了吞吐率的下降。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul>
<li>性能优化属于工程领域，工程领域就需要通过量化方法评判优化结果的好与坏。</li>
<li>在数据分析时除了通过简单美妙的公式描述关系之外还可以通过数据可视化方法得出”数据模式”上的新发现。人的大脑善于从图形化内容中找出相互间的关联性，这个优点也可以用于数据分析。</li>
<li>通过现象看到本质，这应该是我们平时要锻炼的思维模式。 将本质转变成高度抽象的公式是不错的方法之一。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="http://web.mit.edu/~sgraves/www/papers/Little%27s%20Law-Published.pdf" target="_blank" rel="noopener">http://web.mit.edu/~sgraves/www/papers/Little%27s%20Law-Published.pdf</a> //John D.C. Little 发表在MIT刊物上关于Little’s law的论文</li>
<li><a href="https://en.wikipedia.org/wiki/John_Little_(academic" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/John_Little_(academic</a>) // John Little 介绍</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Caveman.Work</p>
              <p class="site-description motion-element" itemprop="description">Life is fantanstic!</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Caveman.Work</span>

  
</div>









        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config("");
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
  


  

  

</body>
</html>
